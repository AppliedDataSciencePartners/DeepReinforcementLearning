import { expectArraysClose, WEBGL_ENVS } from '../test_util';
import { describeWithFlags } from '../jasmine_util';
import { MathBackendWebGL } from './backend_webgl';
describeWithFlags('backendWebGL', WEBGL_ENVS, function () {
    it('delayed storage, reading', function () {
        var delayedStorage = true;
        var backend = new MathBackendWebGL(null, delayedStorage);
        var texManager = backend.getTextureManager();
        var dataId = {};
        backend.register(dataId, [3], 'float32');
        backend.write(dataId, new Float32Array([1, 2, 3]));
        expect(texManager.getNumUsedTextures()).toBe(0);
        backend.getTexture(dataId);
        expect(texManager.getNumUsedTextures()).toBe(1);
        expectArraysClose(backend.readSync(dataId), new Float32Array([1, 2, 3]));
        expect(texManager.getNumUsedTextures()).toBe(0);
        backend.getTexture(dataId);
        expect(texManager.getNumUsedTextures()).toBe(1);
        backend.disposeData(dataId);
        expect(texManager.getNumUsedTextures()).toBe(0);
    });
    it('delayed storage, overwriting', function () {
        var delayedStorage = true;
        var backend = new MathBackendWebGL(null, delayedStorage);
        var texManager = backend.getTextureManager();
        var dataId = {};
        backend.register(dataId, [3], 'float32');
        backend.write(dataId, new Float32Array([1, 2, 3]));
        backend.getTexture(dataId);
        expect(texManager.getNumUsedTextures()).toBe(1);
        backend.write(dataId, new Float32Array([4, 5, 6]));
        expect(texManager.getNumUsedTextures()).toBe(0);
        expectArraysClose(backend.readSync(dataId), new Float32Array([4, 5, 6]));
        backend.getTexture(dataId);
        expect(texManager.getNumUsedTextures()).toBe(1);
        expectArraysClose(backend.readSync(dataId), new Float32Array([4, 5, 6]));
        expect(texManager.getNumUsedTextures()).toBe(0);
    });
    it('immediate storage reading', function () {
        var delayedStorage = false;
        var backend = new MathBackendWebGL(null, delayedStorage);
        var texManager = backend.getTextureManager();
        var dataId = {};
        backend.register(dataId, [3], 'float32');
        backend.write(dataId, new Float32Array([1, 2, 3]));
        expect(texManager.getNumUsedTextures()).toBe(1);
        expectArraysClose(backend.readSync(dataId), new Float32Array([1, 2, 3]));
        expect(texManager.getNumUsedTextures()).toBe(1);
        backend.disposeData(dataId);
        expect(texManager.getNumUsedTextures()).toBe(0);
    });
    it('immediate storage overwriting', function () {
        var delayedStorage = false;
        var backend = new MathBackendWebGL(null, delayedStorage);
        var texManager = backend.getTextureManager();
        var dataId = {};
        backend.register(dataId, [3], 'float32');
        backend.write(dataId, new Float32Array([1, 2, 3]));
        expect(texManager.getNumUsedTextures()).toBe(1);
        backend.write(dataId, new Float32Array([4, 5, 6]));
        expect(texManager.getNumUsedTextures()).toBe(1);
        expectArraysClose(backend.readSync(dataId), new Float32Array([4, 5, 6]));
        expect(texManager.getNumUsedTextures()).toBe(1);
        backend.disposeData(dataId);
        expect(texManager.getNumUsedTextures()).toBe(0);
    });
    it('disposal of backend disposes all textures', function () {
        var delayedStorage = false;
        var backend = new MathBackendWebGL(null, delayedStorage);
        var texManager = backend.getTextureManager();
        var dataId = {};
        backend.register(dataId, [3], 'float32');
        backend.write(dataId, new Float32Array([1, 2, 3]));
        var dataId2 = {};
        backend.register(dataId2, [3], 'float32');
        backend.write(dataId2, new Float32Array([4, 5, 6]));
        expect(texManager.getNumUsedTextures()).toBe(2);
        backend.dispose();
        expect(texManager.getNumUsedTextures()).toBe(0);
    });
});
//# sourceMappingURL=backend_webgl_test.js.map